<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>epispot.pre API documentation</title>
<meta name="description" content="The &#39;pre-compiled&#39; module contains already compiled models which can be put to use immediately.
Each function returns an epispot Model object and its â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://epispot.github.io/images/epispotfavicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://epispot.github.io/images/epispotfavicon.png">
<meta name="theme-color" content="#ffffff">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>epispot.pre</code></h1>
</header>
<section id="section-intro">
<p>The 'pre-compiled' module contains already compiled models which can be put to use immediately.
Each function returns an epispot Model object and its corresponding functions. Models parameters can still be changed
even after compilation.</p>
<h2 id="structure">Structure:</h2>
<ul>
<li>SIR()</li>
<li>SEIR()</li>
<li>SIRD()</li>
<li>SIHRD()</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The &#39;pre-compiled&#39; module contains already compiled models which can be put to use immediately.
Each function returns an epispot Model object and its corresponding functions. Models parameters can still be changed
even after compilation.
## Structure:
- SIR()
- SEIR()
- SIRD()
- SIHRD()
&#34;&#34;&#34;

from . import comps
from . import models

# ROADMAP
# TODO: Test all model types and replace their corresponding testing files
# TODO: Update CI on epispot/epispot to test with new files


def SIR(R_0, N, p_recovery, recovery_rate):
    &#34;&#34;&#34;
    The well-known SIR Model; a staple of epidemiology and the most basic tool for modeling infectious diseases
    ```
    Susceptible --&gt; Infected --&gt; Removed
    ```

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected
         Implemented as a function R_0(t):
        - t: time
        - return: R_0 value
    - N: the total population
        Implemented as a function N(t):
        - t: time 
        - return: total population

    - p_recovery: probability of recovery
         Implemented as a function p_recovery(t):
        - t: time 
        - return: probability of recovery

    - recovery_rate: the recovery rate--different from the standard recovery rate `gamma`
    measures only 1 / the time it takes to move to the Recovered layer
     Implemented as a function recovery_rate(t): 
        - t: time 
        - return: recovery rate
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Infected = comps.Infected(1, N, R_0=R_0, gamma=gamma, p_recovery=p_recovery, recovery_rate=recovery_rate)
    Removed = comps.Recovered(2, p_from_inf=p_recovery, from_inf_rate=recovery_rate)

    # compile model
    SIR_Model = models.Model(N(0))
    SIR_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Infected])
    SIR_Model.add_layer(Infected, &#39;Infected&#39;, [Removed])
    SIR_Model.add_layer(Removed, &#39;Removed&#39;, [])

    return SIR_Model


def SEIR(R_0, N, p_recovery, recovery_rate, delta):
    &#34;&#34;&#34;
    The SEIR Model; a variant of the SIR Model that investigates people who have been *exposed* to the virus
    so that they can be tracked down for contact tracing reasons

    `Susceptible --&gt; Exposed --&gt; Infected --&gt; Removed` &lt;br&gt;&lt;br&gt;

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected
         Implemented as a function R_0(t):
        - t: time
        - return:  R_0 value
    - N: the total population
       Implemented as a function N(t):
        - t: time
        - return:  total population
    - p_recovery: probability of recovery
                Implemented as a function p_recovery(t):
        - t: time
        - return:  probability of recovery
    - recovery_rate: the recovery rate--different from the standard recovery rate `gamma`
                   measures only 1 / the time it takes to move to the Recovered layer
                   Implemented as a function recovery_rate(t):
        - t: time
        - return:   recovery rate
    - delta: Defaults to None, the incubation period
                  Implemented as a function delta(t)--in most cases this should stay constant
        - t: time
        - return:  incubation period
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Exposed = comps.Exposed(1, R_0, gamma, N, delta)
    Infected = comps.Infected(2, N, delta=delta, p_recovery=p_recovery, recovery_rate=recovery_rate)
    Removed = comps.Recovered(3, p_from_inf=p_recovery, from_inf_rate=recovery_rate)

    # compile model
    SEIR_Model = models.Model(N(0))
    SEIR_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Exposed])
    SEIR_Model.add_layer(Exposed, &#39;Exposed&#39;, [Infected])
    SEIR_Model.add_layer(Infected, &#39;Infected&#39;, [Removed])
    SEIR_Model.add_layer(Removed, &#39;Removed&#39;, [])

    return SEIR_Model


def SIRD(R_0, N, p_recovery, recovery_rate, alpha, rho):
    &#34;&#34;&#34;
    The SIRD Model; a tweak on the SIR Model to separate Recovered &amp; Dead compartments
    which allows for death predictions as well as herd immunity predictions

        Susceptible --&gt; Infected --&gt; Recovered 
                    |----------&gt; Dead

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected Implemented as a function R_0(t):
        - t: time
        - return: R_0 value
    - N: the total population
       Implemented as a function N(t):
        - t: time
        - return:  total population
    - p_recovery: probability of recovery
                Implemented as a function p_recovery(t):
        - t: time
        - return:  probability of recovery
    - recovery_rate: the recovery rate--different from the standard recovery rate `gamma`
                   measures only 1 / the time it takes to move to the Recovered layer
                   Implemented as a function recovery_rate(t):
        - t: time
        - return:   recovery rate
    - rho: 1 / time until death
         Implemented as a function rho(t)--in most cases this should stay constant
        - t: time
        - return:  death rate
    - alpha: probability of death from Infected
           Implemented as a function alpha(t)
        - t: time
        - return:  probability of death
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t) + alpha(t) * rho(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Infected = comps.Infected(1, N, R_0=R_0, gamma=gamma, p_recovery=p_recovery, recovery_rate=recovery_rate,
                              death_rate=rho, p_death=alpha)
    Recovered = comps.Recovered(2, p_from_inf=p_recovery, from_inf_rate=recovery_rate)
    Dead = comps.Dead(3, rho_inf=rho, alpha_inf=alpha)

    # compile model
    SIRD_Model = models.Model(N(0))
    SIRD_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Infected])
    SIRD_Model.add_layer(Infected, &#39;Infected&#39;, [Recovered, Dead])
    SIRD_Model.add_layer(Recovered, &#39;Recovered&#39;, [])
    SIRD_Model.add_layer(Dead, &#39;Dead&#39;, [])

    return SIRD_Model


def SIHRD(R_0, N, p_recovery, recovery_rate, alpha, rho, p_hos, hos_rate, p_hos_to_rec, hos_to_rec_rate):
    &#34;&#34;&#34;
    The SIHRD Model; Tracks patients from hospitalized to recovered to dead
    which allows for death, herd immunity, and triage predictions
    ```
    Susceptible --&gt; Infected --&gt; Hospitalized --&gt; Dead 
                    |            |--------------&gt; Recovered 
                    |---------------------------/
    ```

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected
         Implemented as a function R_0(t):
        - t: time
        - return: R_0 value
    - N: the total population
       Implemented as a function N(t):
        - t: time
        - return: total population
    - p_recovery: probability of recovery from Infected
                Implemented as a function p_recovery(t):
        - t: time
        - return: probability of recovery
    - recovery_rate: the recovery rate from the Infected layer only. Implemented as a function recovery_rate(t):
        - t: time
        - return:  recovery rate
    - rho: 1 / time until death. Implemented as a function rho(t)--in most cases this should stay constant
        - t: time
        - return: death rate
    - alpha: probability of death from Infected
           Implemented as a function alpha(t)
        - t: time
        - return: probability of death
    - p_hos_to_rec: probability of recovery from Hospitalized
                Implemented as a function p_hos_to_rec(t):
        - t: time
        - return: probability of recovery
    - hos_to_rec_rate: the recovery rate from the Hospitalized layer only
                   Implemented as a function hos_to_rec_rate(t):
        - t: time
        - return:  recovery rate
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t) + p_hos(t) * hos_rate(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Infected = comps.Infected(1, N, R_0=R_0, gamma=gamma, hospital_rate=hos_rate, p_hospitalized=p_hos,
                              recovery_rate=recovery_rate, p_recovery=p_recovery)
    Hospitalized = comps.Hospitalized(2, hos_rate=hos_rate, p_hos=p_hos, p_recovery=p_hos_to_rec,
                                      recovery_rate=hos_to_rec_rate, rho=rho, alpha=alpha)
    Recovered = comps.Recovered(3, p_from_hos=p_hos_to_rec, from_hos_rate=hos_to_rec_rate,
                                p_from_inf=p_recovery, from_inf_rate=recovery_rate)
    Dead = comps.Dead(4, rho_hos=rho, alpha_hos=alpha)

    # compile model
    SIHRD_Model = models.Model(N(0))
    SIHRD_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Infected])
    SIHRD_Model.add_layer(Infected, &#39;Infected&#39;, [Hospitalized])
    SIHRD_Model.add_layer(Hospitalized, &#39;Hospitalized&#39;, [Recovered, Dead])
    SIHRD_Model.add_layer(Recovered, &#39;Recovered&#39;, [])
    SIHRD_Model.add_layer(Dead, &#39;Dead&#39;, [])

    return SIHRD_Model</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="epispot.pre.SEIR"><code class="name flex">
<span>def <span class="ident fname">SEIR</span></span>(<span>R_0, N, p_recovery, recovery_rate, delta)</span>
</code></dt>
<dd>
<div class="desc"><p>The SEIR Model; a variant of the SIR Model that investigates people who have been <em>exposed</em> to the virus
so that they can be tracked down for contact tracing reasons</p>
<p><code>Susceptible --&gt; Exposed --&gt; Infected --&gt; Removed</code> <br><br></p>
<ul>
<li>R_0: the basic reproductive number&ndash;
this is the average number of susceptibles infected by one infected
Implemented as a function R_0(t):<ul>
<li>t: time</li>
<li>return:
R_0 value</li>
</ul>
</li>
<li>N: the total population
Implemented as a function N(t):<ul>
<li>t: time</li>
<li>return:
total population</li>
</ul>
</li>
<li>p_recovery: probability of recovery
Implemented as a function p_recovery(t):<ul>
<li>t: time</li>
<li>return:
probability of recovery</li>
</ul>
</li>
<li>recovery_rate: the recovery rate&ndash;different from the standard recovery rate <code>gamma</code>
measures only 1 / the time it takes to move to the Recovered layer
Implemented as a function recovery_rate(t):<ul>
<li>t: time</li>
<li>return:
recovery rate</li>
</ul>
</li>
<li>delta: Defaults to None, the incubation period
Implemented as a function delta(t)&ndash;in most cases this should stay constant<ul>
<li>t: time</li>
<li>return:
incubation period</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SEIR(R_0, N, p_recovery, recovery_rate, delta):
    &#34;&#34;&#34;
    The SEIR Model; a variant of the SIR Model that investigates people who have been *exposed* to the virus
    so that they can be tracked down for contact tracing reasons

    `Susceptible --&gt; Exposed --&gt; Infected --&gt; Removed` &lt;br&gt;&lt;br&gt;

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected
         Implemented as a function R_0(t):
        - t: time
        - return:  R_0 value
    - N: the total population
       Implemented as a function N(t):
        - t: time
        - return:  total population
    - p_recovery: probability of recovery
                Implemented as a function p_recovery(t):
        - t: time
        - return:  probability of recovery
    - recovery_rate: the recovery rate--different from the standard recovery rate `gamma`
                   measures only 1 / the time it takes to move to the Recovered layer
                   Implemented as a function recovery_rate(t):
        - t: time
        - return:   recovery rate
    - delta: Defaults to None, the incubation period
                  Implemented as a function delta(t)--in most cases this should stay constant
        - t: time
        - return:  incubation period
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Exposed = comps.Exposed(1, R_0, gamma, N, delta)
    Infected = comps.Infected(2, N, delta=delta, p_recovery=p_recovery, recovery_rate=recovery_rate)
    Removed = comps.Recovered(3, p_from_inf=p_recovery, from_inf_rate=recovery_rate)

    # compile model
    SEIR_Model = models.Model(N(0))
    SEIR_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Exposed])
    SEIR_Model.add_layer(Exposed, &#39;Exposed&#39;, [Infected])
    SEIR_Model.add_layer(Infected, &#39;Infected&#39;, [Removed])
    SEIR_Model.add_layer(Removed, &#39;Removed&#39;, [])

    return SEIR_Model</code></pre>
</details>
</dd>
<dt id="epispot.pre.SIHRD"><code class="name flex">
<span>def <span class="ident fname">SIHRD</span></span>(<span>R_0, N, p_recovery, recovery_rate, alpha, rho, p_hos, hos_rate, p_hos_to_rec, hos_to_rec_rate)</span>
</code></dt>
<dd>
<div class="desc"><p>The SIHRD Model; Tracks patients from hospitalized to recovered to dead
which allows for death, herd immunity, and triage predictions</p>
<pre><code>Susceptible --&gt; Infected --&gt; Hospitalized --&gt; Dead 
                |            |--------------&gt; Recovered 
                |---------------------------/
</code></pre>
<ul>
<li>R_0: the basic reproductive number&ndash;
this is the average number of susceptibles infected by one infected
Implemented as a function R_0(t):<ul>
<li>t: time</li>
<li>return: R_0 value</li>
</ul>
</li>
<li>N: the total population
Implemented as a function N(t):<ul>
<li>t: time</li>
<li>return: total population</li>
</ul>
</li>
<li>p_recovery: probability of recovery from Infected
Implemented as a function p_recovery(t):<ul>
<li>t: time</li>
<li>return: probability of recovery</li>
</ul>
</li>
<li>recovery_rate: the recovery rate from the Infected layer only. Implemented as a function recovery_rate(t):<ul>
<li>t: time</li>
<li>return:
recovery rate</li>
</ul>
</li>
<li>rho: 1 / time until death. Implemented as a function rho(t)&ndash;in most cases this should stay constant<ul>
<li>t: time</li>
<li>return: death rate</li>
</ul>
</li>
<li>alpha: probability of death from Infected
Implemented as a function alpha(t)<ul>
<li>t: time</li>
<li>return: probability of death</li>
</ul>
</li>
<li>p_hos_to_rec: probability of recovery from Hospitalized
Implemented as a function p_hos_to_rec(t):<ul>
<li>t: time</li>
<li>return: probability of recovery</li>
</ul>
</li>
<li>hos_to_rec_rate: the recovery rate from the Hospitalized layer only
Implemented as a function hos_to_rec_rate(t):<ul>
<li>t: time</li>
<li>return:
recovery rate</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SIHRD(R_0, N, p_recovery, recovery_rate, alpha, rho, p_hos, hos_rate, p_hos_to_rec, hos_to_rec_rate):
    &#34;&#34;&#34;
    The SIHRD Model; Tracks patients from hospitalized to recovered to dead
    which allows for death, herd immunity, and triage predictions
    ```
    Susceptible --&gt; Infected --&gt; Hospitalized --&gt; Dead 
                    |            |--------------&gt; Recovered 
                    |---------------------------/
    ```

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected
         Implemented as a function R_0(t):
        - t: time
        - return: R_0 value
    - N: the total population
       Implemented as a function N(t):
        - t: time
        - return: total population
    - p_recovery: probability of recovery from Infected
                Implemented as a function p_recovery(t):
        - t: time
        - return: probability of recovery
    - recovery_rate: the recovery rate from the Infected layer only. Implemented as a function recovery_rate(t):
        - t: time
        - return:  recovery rate
    - rho: 1 / time until death. Implemented as a function rho(t)--in most cases this should stay constant
        - t: time
        - return: death rate
    - alpha: probability of death from Infected
           Implemented as a function alpha(t)
        - t: time
        - return: probability of death
    - p_hos_to_rec: probability of recovery from Hospitalized
                Implemented as a function p_hos_to_rec(t):
        - t: time
        - return: probability of recovery
    - hos_to_rec_rate: the recovery rate from the Hospitalized layer only
                   Implemented as a function hos_to_rec_rate(t):
        - t: time
        - return:  recovery rate
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t) + p_hos(t) * hos_rate(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Infected = comps.Infected(1, N, R_0=R_0, gamma=gamma, hospital_rate=hos_rate, p_hospitalized=p_hos,
                              recovery_rate=recovery_rate, p_recovery=p_recovery)
    Hospitalized = comps.Hospitalized(2, hos_rate=hos_rate, p_hos=p_hos, p_recovery=p_hos_to_rec,
                                      recovery_rate=hos_to_rec_rate, rho=rho, alpha=alpha)
    Recovered = comps.Recovered(3, p_from_hos=p_hos_to_rec, from_hos_rate=hos_to_rec_rate,
                                p_from_inf=p_recovery, from_inf_rate=recovery_rate)
    Dead = comps.Dead(4, rho_hos=rho, alpha_hos=alpha)

    # compile model
    SIHRD_Model = models.Model(N(0))
    SIHRD_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Infected])
    SIHRD_Model.add_layer(Infected, &#39;Infected&#39;, [Hospitalized])
    SIHRD_Model.add_layer(Hospitalized, &#39;Hospitalized&#39;, [Recovered, Dead])
    SIHRD_Model.add_layer(Recovered, &#39;Recovered&#39;, [])
    SIHRD_Model.add_layer(Dead, &#39;Dead&#39;, [])

    return SIHRD_Model</code></pre>
</details>
</dd>
<dt id="epispot.pre.SIR"><code class="name flex">
<span>def <span class="ident fname">SIR</span></span>(<span>R_0, N, p_recovery, recovery_rate)</span>
</code></dt>
<dd>
<div class="desc"><p>The well-known SIR Model; a staple of epidemiology and the most basic tool for modeling infectious diseases</p>
<pre><code>Susceptible --&gt; Infected --&gt; Removed
</code></pre>
<ul>
<li>R_0: the basic reproductive number&ndash;
this is the average number of susceptibles infected by one infected
Implemented as a function R_0(t):<ul>
<li>t: time</li>
<li>return: R_0 value</li>
</ul>
</li>
<li>
<p>N: the total population
Implemented as a function N(t):</p>
<ul>
<li>t: time </li>
<li>return: total population</li>
</ul>
</li>
<li>
<p>p_recovery: probability of recovery
Implemented as a function p_recovery(t):</p>
<ul>
<li>t: time </li>
<li>return: probability of recovery</li>
</ul>
</li>
<li>
<p>recovery_rate: the recovery rate&ndash;different from the standard recovery rate <code>gamma</code>
measures only 1 / the time it takes to move to the Recovered layer
Implemented as a function recovery_rate(t): </p>
<ul>
<li>t: time </li>
<li>return: recovery rate</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SIR(R_0, N, p_recovery, recovery_rate):
    &#34;&#34;&#34;
    The well-known SIR Model; a staple of epidemiology and the most basic tool for modeling infectious diseases
    ```
    Susceptible --&gt; Infected --&gt; Removed
    ```

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected
         Implemented as a function R_0(t):
        - t: time
        - return: R_0 value
    - N: the total population
        Implemented as a function N(t):
        - t: time 
        - return: total population

    - p_recovery: probability of recovery
         Implemented as a function p_recovery(t):
        - t: time 
        - return: probability of recovery

    - recovery_rate: the recovery rate--different from the standard recovery rate `gamma`
    measures only 1 / the time it takes to move to the Recovered layer
     Implemented as a function recovery_rate(t): 
        - t: time 
        - return: recovery rate
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Infected = comps.Infected(1, N, R_0=R_0, gamma=gamma, p_recovery=p_recovery, recovery_rate=recovery_rate)
    Removed = comps.Recovered(2, p_from_inf=p_recovery, from_inf_rate=recovery_rate)

    # compile model
    SIR_Model = models.Model(N(0))
    SIR_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Infected])
    SIR_Model.add_layer(Infected, &#39;Infected&#39;, [Removed])
    SIR_Model.add_layer(Removed, &#39;Removed&#39;, [])

    return SIR_Model</code></pre>
</details>
</dd>
<dt id="epispot.pre.SIRD"><code class="name flex">
<span>def <span class="ident fname">SIRD</span></span>(<span>R_0, N, p_recovery, recovery_rate, alpha, rho)</span>
</code></dt>
<dd>
<div class="desc"><p>The SIRD Model; a tweak on the SIR Model to separate Recovered &amp; Dead compartments
which allows for death predictions as well as herd immunity predictions</p>
<pre><code>Susceptible --&gt; Infected --&gt; Recovered 
            |----------&gt; Dead
</code></pre>
<ul>
<li>R_0: the basic reproductive number&ndash;
this is the average number of susceptibles infected by one infected Implemented as a function R_0(t):<ul>
<li>t: time</li>
<li>return: R_0 value</li>
</ul>
</li>
<li>N: the total population
Implemented as a function N(t):<ul>
<li>t: time</li>
<li>return:
total population</li>
</ul>
</li>
<li>p_recovery: probability of recovery
Implemented as a function p_recovery(t):<ul>
<li>t: time</li>
<li>return:
probability of recovery</li>
</ul>
</li>
<li>recovery_rate: the recovery rate&ndash;different from the standard recovery rate <code>gamma</code>
measures only 1 / the time it takes to move to the Recovered layer
Implemented as a function recovery_rate(t):<ul>
<li>t: time</li>
<li>return:
recovery rate</li>
</ul>
</li>
<li>rho: 1 / time until death
Implemented as a function rho(t)&ndash;in most cases this should stay constant<ul>
<li>t: time</li>
<li>return:
death rate</li>
</ul>
</li>
<li>alpha: probability of death from Infected
Implemented as a function alpha(t)<ul>
<li>t: time</li>
<li>return:
probability of death</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SIRD(R_0, N, p_recovery, recovery_rate, alpha, rho):
    &#34;&#34;&#34;
    The SIRD Model; a tweak on the SIR Model to separate Recovered &amp; Dead compartments
    which allows for death predictions as well as herd immunity predictions

        Susceptible --&gt; Infected --&gt; Recovered 
                    |----------&gt; Dead

    - R_0: the basic reproductive number--
         this is the average number of susceptibles infected by one infected Implemented as a function R_0(t):
        - t: time
        - return: R_0 value
    - N: the total population
       Implemented as a function N(t):
        - t: time
        - return:  total population
    - p_recovery: probability of recovery
                Implemented as a function p_recovery(t):
        - t: time
        - return:  probability of recovery
    - recovery_rate: the recovery rate--different from the standard recovery rate `gamma`
                   measures only 1 / the time it takes to move to the Recovered layer
                   Implemented as a function recovery_rate(t):
        - t: time
        - return:   recovery rate
    - rho: 1 / time until death
         Implemented as a function rho(t)--in most cases this should stay constant
        - t: time
        - return:  death rate
    - alpha: probability of death from Infected
           Implemented as a function alpha(t)
        - t: time
        - return:  probability of death
    &#34;&#34;&#34;

    def gamma(t):
        return p_recovery(t) * recovery_rate(t) + alpha(t) * rho(t)

    # compile compartments
    Susceptible = comps.Susceptible(0, R_0, gamma, N)
    Infected = comps.Infected(1, N, R_0=R_0, gamma=gamma, p_recovery=p_recovery, recovery_rate=recovery_rate,
                              death_rate=rho, p_death=alpha)
    Recovered = comps.Recovered(2, p_from_inf=p_recovery, from_inf_rate=recovery_rate)
    Dead = comps.Dead(3, rho_inf=rho, alpha_inf=alpha)

    # compile model
    SIRD_Model = models.Model(N(0))
    SIRD_Model.add_layer(Susceptible, &#39;Susceptible&#39;, [Infected])
    SIRD_Model.add_layer(Infected, &#39;Infected&#39;, [Recovered, Dead])
    SIRD_Model.add_layer(Recovered, &#39;Recovered&#39;, [])
    SIRD_Model.add_layer(Dead, &#39;Dead&#39;, [])

    return SIRD_Model</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="epispot" href="https://github.com/epispot/epispot">
<img alt="epispot logo"src="https://camo.githubusercontent.com/87a2a010e6ffdcef771467821c6bc034a01a00e7903e2d7d47ee95d9cb7ef23a/68747470733a2f2f692e6962622e636f2f68584d6a7243562f6570692d73706f742e706e67"/>
<br>
<p>epispot</p>
</a>
</header>
<input type="text" placeholder="Search..." id='search_input'> </input>
<br>
<br>
<div>
<div class="toc">
<ul>
<li><a href="#structure">Structure:</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="epispot" href="index.html">epispot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="epispot.pre.SEIR" href="#epispot.pre.SEIR">SEIR</a></code></li>
<li><code><a title="epispot.pre.SIHRD" href="#epispot.pre.SIHRD">SIHRD</a></code></li>
<li><code><a title="epispot.pre.SIR" href="#epispot.pre.SIR">SIR</a></code></li>
<li><code><a title="epispot.pre.SIRD" href="#epispot.pre.SIRD">SIRD</a></code></li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'ca8d2c9b20faf530dec51dcce701d48a',
indexName: 'epispot',
inputSelector: 'search_input',
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>
</html>