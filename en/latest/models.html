<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>epispot.models API documentation</title>
<meta name="description" content="The `epispot.models` classes store different types of epidemiological
models in a compact form useful for integration. Models can be
differentiated, …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>epispot.models</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="epispot.models" href="#epispot.models">epispot.models</a></code> classes store different types of epidemiological
models in a compact form useful for integration. Models can be
differentiated, integrated, and examined by calling class methods.
Additionally, epispot models are portable—they can be used throughout
the package to generate plots, run predictions, etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The `epispot.models` classes store different types of epidemiological
models in a compact form useful for integration. Models can be
differentiated, integrated, and examined by calling class methods.
Additionally, epispot models are portable—they can be used throughout
the package to generate plots, run predictions, etc.
&#34;&#34;&#34;

from copy import deepcopy

from . import dill, np, version, warnings


class Model:
    &#34;&#34;&#34;
    The base model class for
    [compartmental models](https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology).
    Compartmental models are models composed of various sub-models,
    known as &#34;compartments.&#34;
    For example, the common SIR model is an example of a compartmental model with the Susceptible,
    Infected, and Removed compartments.

    .. versionadded:: v3.0.0-alpha-2
    &#34;&#34;&#34;

    def __init__(self, initial_population, comps=None, comp_map=None,
                 matrix=None):
        &#34;&#34;&#34;
        Initialize the `Model` class; all optional parameters can be added through the `epispot.models.Model.add` method.

        ## Parameters

        `initial_population (int)`: Population at time zero

        `comps=None (|list[epispot.comps.Compartment])`: List of compartment classes to create the model

        `comp_map=None (|list[list[int]])`: Map of how all the compartments connect.
            The map should consist of a list of lists.
            Each sublist represents the connections of the corresponding compartment in the `comps` list.
            This sublist should contain the indices of each of the compartments in `comps` that it connects to.
            If the compartment does not connect to any other compartments,
            leave the sublist blank.

        `matrix=None (|list[list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)]])`:
            Rate and probability matrix describing the exchange rates between compartments.
            Like `map`, this is a list of lists.
            Unlike `map`, however, this matrix must not skip entries
            (i.e. no blank sublists).
            Each sublist should contain rate and probability information
            in a tuple for every compartment.
            If the information is not necessary, use the tuple `(1, 1)`
            as a placeholder.

        ## Example

        Let&#39;s say we have three compartments `A`, `B`, and `C`.
        These three compartments connect as shown below:

            ┌─────────────────────┐
            │                     ▼
            ┌───┐     ┌───┐     ┌───┐
            │ A │ ──&gt; │ C │ ──&gt; │ B │
            └───┘     └───┘     └───┘

        To create a compartmental model with these three classes, use:

        ```python
        comps = [A, B, C],
        map = [
            [1, 2],     # A
            [],         # B
            [1]         # C
        ],
        matrix = [
            [(1, 1), (1/2, 1/3), (1/2, 1/3)],     # A[A, B, C]
            [(1, 1), (1, 1), (1, 1)],                 # B[A, B, C]
            [(1, 1), (1/2, 1/3), (1, 1)]            # C[A, B, C]
        ]
        ```

        This creates a compartmental model where all the connections
        have a probability of `1/2` and rate of `1/3`.

        ## **Additional Notes**

        For more information about this
        feature, or if you&#39;re interested in giving feedback, see the
        discussion
        [here on GitHub](https://github.com/epispot/epispot/issues/73).

        ..versionadded:: v3.0.0-alpha-2

        &#34;&#34;&#34;
        self.initial_population = initial_population
        self.compartments = comps
        if self.compartments:
            self.names = [comp.name for comp in self.compartments]
        self.map = comp_map
        self.matrix = matrix
        self.aggregated = None
        self.compiled = False
        self.version = version

    def compile(self, custom=False):
        &#34;&#34;&#34;
        Run a series of checks of the model and initialize some class-wide variables.

        ## Parameters

        `custom=False (bool)`: Flag indicating if the model is using custom compartments.
            If this is `False` (the default), all compartment compatibility checks will have to pass or an error will be raised.
            If this is `True`, those checks are bypassed since the model cannot check for custom compartments.

        ## Additional Notes

        Adding, removing, or modifying compartments after this step will automatically de-compile the model,
        requiring it to be compiled again after changes have been made.

        .. important::
           Only run after all the compartments have been
           added to the model.

        &#34;&#34;&#34;
        if self.compiled:  # pragma: no cover
            warnings.warn(&#34;It looks like you&#39;re compiling a model more &#34;
                          &#34;than once. For clarity, it is recommended &#34;
                          &#34;that you only compile models once, and then &#34;
                          &#34;again if (and only if) changes have been &#34;
                          &#34;made.&#34;)

        # run model checks to ensure that the model is valid
        if not custom:
            for i, compartment in enumerate(self.compartments):
                compartment._check(self.map[i], self.compartments)

        # aggregate all compartments by type
        self.aggregated = {}
        for i, compartment in enumerate(self.compartments):
            if compartment.config[&#39;type&#39;] not in self.aggregated:
                self.aggregated[compartment.config[&#39;type&#39;]] = []
            self.aggregated[compartment.config[&#39;type&#39;]].append(i)

        self.compiled = True

    def diff(self, time, system):
        &#34;&#34;&#34;
        Differentiate `epispot.models.Model`; used by `epispot.models.Model.integrate` for evaluating model predictions.

        ## Parameters

        `time (float)`: Time to take the derivative at.
            This is important for some time-dependent variables like compartment parameters.

        `system (list[float])`: System of state values (e.g `[973, 12, 15]`).
            This is propagated to each of the individual compartments in the model.

        ## Returns

        List of corresponding compartment derivatives (`list[float]`)

        &#34;&#34;&#34;
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        derivative = np.zeros((len(self.compartments), ))
        for num, compartment in enumerate(self.compartments):
            if num in self.aggregated[&#39;Susceptible&#39;]:
                delta = compartment.diff(
                    time, system, num,
                    self.map[num], self.matrix[num],
                    infecteds=self.aggregated[&#39;Infected&#39;]
                )
            else:
                delta = compartment.diff(time,
                                         system,
                                         num,
                                         self.map[num],
                                         self.matrix[num])
            derivative += delta

        return derivative

    def integrate(self, timesteps, starting_state=None):
        &#34;&#34;&#34;
        Integrate the model using `epispot.models.Model.diff` to arrive at future predictions using
        [Euler&#39;s Method](https://en.wikipedia.org/wiki/Euler_method).
        By default, the step size (Δ) is set to exactly 1 day, as this is usually the period for which epidemiological parameters are estimated for.
        However, this can be changed if necessary.

        ## Parameters

        `timesteps (range)`: range of evenly-spaced times starting at the epidemic start time and ending at the time of prediction.

        `starting_state=None (|list[int])`: List of initial values for each compartment.
            This is used as the initial vector for the integration process.
            If no `starting_state` is provided, it will default to the having only 1 person in the next non-Susceptible compartment.

        `delta=1 (|float)`: Δ, the step size for the integration process.
            Smaller values will result in more accurate predictions,
            but will be more costly.

        ## Returns

        A list of lists; each sublist is a vector representing the value of each compartment at that specific time.
        The sublists range according to the `timesteps` parameter.
        (`list[list[float]]`)

        ## Example

        For example, the following would be an expected return type for
        an SIR model with a population of `100`:

        ```python
        [
            [99, 1, 0],  # S, I, R on day 1
            [98, 2, 0],  # S, I, R on day 2
            [95, 3, 2],  # S, I, R on day 3
            ...,
            [23, 24, 53]  # final prediction
        ]
        ```

        &#34;&#34;&#34;
        # checks to make sure the model has been compiled
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        # initial parameter setup
        results = []

        if starting_state is not None:
            system = starting_state
        else:
            system = np.zeros(len(self.compartments))
            system[0] = self.initial_population - 1
            system[1] = 1

        delta = timesteps[1] - timesteps[0]

        for timestep in timesteps:

            # calculate the derivative for each compartment at this
            # timestep and update the system accordingly

            derivatives = self.diff(timestep, system)
            system += delta * derivatives
            results.append(deepcopy(system))

        return results

    def add(self, comp, comp_map, matrix):
        &#34;&#34;&#34;
        Add a compartment to the model.
        This can also be done by initializing the `epispot.models.Model` class beforehand.

        ## Parameters

        `comp (epispot.comps.Compartment)`: Compartment class (e.g. `epispot.comps.Susceptible` or `epispot.comps.Infected`)

        `comp_map (list[int])`: Slice of the larger `map` specified in `epispot.models.Model`.
            This should simply include the compartment connections for this specific compartment.

        `matrix (list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)])`: Slice of the larger `matrix` specified in
                  `epispot.models.Model`. As with `map`, this should
                  only include the rates and probabilities for this
                  compartment&#39;s connections.

        ## Error Handling

        Initializing some parameters in `epispot.models.Model` without initializing all of them will raise a `ValueError`.

        ## Additional Notes

        See the documentation for `epispot.models.Model` for more help and examples.

        &#34;&#34;&#34;
        if self.compiled:
            self.compiled = False

        if (self.compartments, self.map, self.matrix) == (None, None, None):
            self.compartments = [comp]
            self.names = [comp.name]
            self.map = [comp_map]
            self.matrix = [matrix]
        elif self.compartments is not None \
            and self.map is not None \
            and self.matrix is not None:
            self.compartments.append(comp)
            self.names.append(comp.name)
            self.map.append(comp_map)
            self.matrix.append(matrix)
        else:  # pragma: no cover
            raise ValueError(&#39;Parameters for `epispot.models.Model` &#39;
                             &#39;have not been specified correctly.\n&#39;
                             &#39;If either `comps`, `map`, or `matrix` &#39;
                             &#39;have been initialized, then *all* &#39;
                             &#39;parameters must be initialized.&#39;)

    def rename(self, names):
        &#34;&#34;&#34;
        Assign names to each compartment in the model.

        ## Parameters

        `names (list[str])`: A list of names corresponding to `comps`

        &#34;&#34;&#34;
        self.names = names
        for i, comp in enumerate(self.compartments):
            comp.name = names[i]

    def save(self, filename):
        &#34;&#34;&#34;
        Save the model to a file.
        This can be used to load the model later.
        Standard file ending is `.epi`.

        ## Parameters

        `filename (str)`: Name of the file to save the model to

        ## Error Handling

        - If the file already exists, it will be overwritten.
        - If the model is not compiled, it will raise a `ValueError`.

        &#34;&#34;&#34;
        if not self.compiled:  # pragma: no cover
            raise ValueError(&#39;Model has not been compiled yet. &#39;
                             &#39;Cannot save model.&#39;)

        with open(filename, &#39;wb&#39;) as f:
            dill.dump(self, f)

    @classmethod
    def load(cls, filename):
        &#34;&#34;&#34;
        Load a model from a file.

        ## Parameters

        `filename (str)`: Name of the file to load the model from

        ## Security

        ..warning::
            Be careful when loading a model from a file. Untrusted sources
            could potentially embed malicious code into various parts of the
            model which can lead to arbitrary code execution.

        ## Error Handling

        - If the file does not exist, it will raise a
          `FileNotFoundError`.

        &#34;&#34;&#34;
        with open(filename, &#39;rb&#39;) as f:
            loaded = dill.load(f)
            if not loaded.compiled:  # pragma: no cover
                loaded.compile()
            if loaded.version != version:  # pragma: no cover
                warnings.warn(
                    &#39;This model has been imported from an &#39;
                    f&#39;older version of epispot v{loaded.version}. &#39;
                    f&#39;You have epispot v{version}.&#39;
                )
            return loaded</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="epispot.models.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>initial_population, comps=None, comp_map=None, matrix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base model class for
<a href="https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology">compartmental models</a>.
Compartmental models are models composed of various sub-models,
known as "compartments."
For example, the common SIR model is an example of a compartmental model with the Susceptible,
Infected, and Removed compartments.</p>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;v3.0.0-alpha-2</p>
</div>
<p>Initialize the <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> class; all optional parameters can be added through the <code><a title="epispot.models.Model.add" href="#epispot.models.Model.add">Model.add()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<p><code>initial_population (int)</code>: Population at time zero</p>
<p><code>comps=None (|list[epispot.comps.Compartment])</code>: List of compartment classes to create the model</p>
<p><code>comp_map=None (|list[list[int]])</code>: Map of how all the compartments connect.
The map should consist of a list of lists.
Each sublist represents the connections of the corresponding compartment in the <code>comps</code> list.
This sublist should contain the indices of each of the compartments in <code>comps</code> that it connects to.
If the compartment does not connect to any other compartments,
leave the sublist blank.</p>
<p><code>matrix=None (|list[list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)]])</code>:
Rate and probability matrix describing the exchange rates between compartments.
Like <code>map</code>, this is a list of lists.
Unlike <code>map</code>, however, this matrix must not skip entries
(i.e. no blank sublists).
Each sublist should contain rate and probability information
in a tuple for every compartment.
If the information is not necessary, use the tuple <code>(1, 1)</code>
as a placeholder.</p>
<h2 id="example">Example</h2>
<p>Let's say we have three compartments <code>A</code>, <code>B</code>, and <code>C</code>.
These three compartments connect as shown below:</p>
<pre><code>┌─────────────────────┐
│                     ▼
┌───┐     ┌───┐     ┌───┐
│ A │ ──&gt; │ C │ ──&gt; │ B │
└───┘     └───┘     └───┘
</code></pre>
<p>To create a compartmental model with these three classes, use:</p>
<pre><code class="language-python">comps = [A, B, C],
map = [
    [1, 2],     # A
    [],         # B
    [1]         # C
],
matrix = [
    [(1, 1), (1/2, 1/3), (1/2, 1/3)],     # A[A, B, C]
    [(1, 1), (1, 1), (1, 1)],                 # B[A, B, C]
    [(1, 1), (1/2, 1/3), (1, 1)]            # C[A, B, C]
]
</code></pre>
<p>This creates a compartmental model where all the connections
have a probability of <code>1/2</code> and rate of <code>1/3</code>.</p>
<h2 id="additional-notes"><strong>Additional Notes</strong></h2>
<p>For more information about this
feature, or if you're interested in giving feedback, see the
discussion
<a href="https://github.com/epispot/epispot/issues/73">here on GitHub</a>.</p>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;v3.0.0-alpha-2</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model:
    &#34;&#34;&#34;
    The base model class for
    [compartmental models](https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology).
    Compartmental models are models composed of various sub-models,
    known as &#34;compartments.&#34;
    For example, the common SIR model is an example of a compartmental model with the Susceptible,
    Infected, and Removed compartments.

    .. versionadded:: v3.0.0-alpha-2
    &#34;&#34;&#34;

    def __init__(self, initial_population, comps=None, comp_map=None,
                 matrix=None):
        &#34;&#34;&#34;
        Initialize the `Model` class; all optional parameters can be added through the `epispot.models.Model.add` method.

        ## Parameters

        `initial_population (int)`: Population at time zero

        `comps=None (|list[epispot.comps.Compartment])`: List of compartment classes to create the model

        `comp_map=None (|list[list[int]])`: Map of how all the compartments connect.
            The map should consist of a list of lists.
            Each sublist represents the connections of the corresponding compartment in the `comps` list.
            This sublist should contain the indices of each of the compartments in `comps` that it connects to.
            If the compartment does not connect to any other compartments,
            leave the sublist blank.

        `matrix=None (|list[list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)]])`:
            Rate and probability matrix describing the exchange rates between compartments.
            Like `map`, this is a list of lists.
            Unlike `map`, however, this matrix must not skip entries
            (i.e. no blank sublists).
            Each sublist should contain rate and probability information
            in a tuple for every compartment.
            If the information is not necessary, use the tuple `(1, 1)`
            as a placeholder.

        ## Example

        Let&#39;s say we have three compartments `A`, `B`, and `C`.
        These three compartments connect as shown below:

            ┌─────────────────────┐
            │                     ▼
            ┌───┐     ┌───┐     ┌───┐
            │ A │ ──&gt; │ C │ ──&gt; │ B │
            └───┘     └───┘     └───┘

        To create a compartmental model with these three classes, use:

        ```python
        comps = [A, B, C],
        map = [
            [1, 2],     # A
            [],         # B
            [1]         # C
        ],
        matrix = [
            [(1, 1), (1/2, 1/3), (1/2, 1/3)],     # A[A, B, C]
            [(1, 1), (1, 1), (1, 1)],                 # B[A, B, C]
            [(1, 1), (1/2, 1/3), (1, 1)]            # C[A, B, C]
        ]
        ```

        This creates a compartmental model where all the connections
        have a probability of `1/2` and rate of `1/3`.

        ## **Additional Notes**

        For more information about this
        feature, or if you&#39;re interested in giving feedback, see the
        discussion
        [here on GitHub](https://github.com/epispot/epispot/issues/73).

        ..versionadded:: v3.0.0-alpha-2

        &#34;&#34;&#34;
        self.initial_population = initial_population
        self.compartments = comps
        if self.compartments:
            self.names = [comp.name for comp in self.compartments]
        self.map = comp_map
        self.matrix = matrix
        self.aggregated = None
        self.compiled = False
        self.version = version

    def compile(self, custom=False):
        &#34;&#34;&#34;
        Run a series of checks of the model and initialize some class-wide variables.

        ## Parameters

        `custom=False (bool)`: Flag indicating if the model is using custom compartments.
            If this is `False` (the default), all compartment compatibility checks will have to pass or an error will be raised.
            If this is `True`, those checks are bypassed since the model cannot check for custom compartments.

        ## Additional Notes

        Adding, removing, or modifying compartments after this step will automatically de-compile the model,
        requiring it to be compiled again after changes have been made.

        .. important::
           Only run after all the compartments have been
           added to the model.

        &#34;&#34;&#34;
        if self.compiled:  # pragma: no cover
            warnings.warn(&#34;It looks like you&#39;re compiling a model more &#34;
                          &#34;than once. For clarity, it is recommended &#34;
                          &#34;that you only compile models once, and then &#34;
                          &#34;again if (and only if) changes have been &#34;
                          &#34;made.&#34;)

        # run model checks to ensure that the model is valid
        if not custom:
            for i, compartment in enumerate(self.compartments):
                compartment._check(self.map[i], self.compartments)

        # aggregate all compartments by type
        self.aggregated = {}
        for i, compartment in enumerate(self.compartments):
            if compartment.config[&#39;type&#39;] not in self.aggregated:
                self.aggregated[compartment.config[&#39;type&#39;]] = []
            self.aggregated[compartment.config[&#39;type&#39;]].append(i)

        self.compiled = True

    def diff(self, time, system):
        &#34;&#34;&#34;
        Differentiate `epispot.models.Model`; used by `epispot.models.Model.integrate` for evaluating model predictions.

        ## Parameters

        `time (float)`: Time to take the derivative at.
            This is important for some time-dependent variables like compartment parameters.

        `system (list[float])`: System of state values (e.g `[973, 12, 15]`).
            This is propagated to each of the individual compartments in the model.

        ## Returns

        List of corresponding compartment derivatives (`list[float]`)

        &#34;&#34;&#34;
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        derivative = np.zeros((len(self.compartments), ))
        for num, compartment in enumerate(self.compartments):
            if num in self.aggregated[&#39;Susceptible&#39;]:
                delta = compartment.diff(
                    time, system, num,
                    self.map[num], self.matrix[num],
                    infecteds=self.aggregated[&#39;Infected&#39;]
                )
            else:
                delta = compartment.diff(time,
                                         system,
                                         num,
                                         self.map[num],
                                         self.matrix[num])
            derivative += delta

        return derivative

    def integrate(self, timesteps, starting_state=None):
        &#34;&#34;&#34;
        Integrate the model using `epispot.models.Model.diff` to arrive at future predictions using
        [Euler&#39;s Method](https://en.wikipedia.org/wiki/Euler_method).
        By default, the step size (Δ) is set to exactly 1 day, as this is usually the period for which epidemiological parameters are estimated for.
        However, this can be changed if necessary.

        ## Parameters

        `timesteps (range)`: range of evenly-spaced times starting at the epidemic start time and ending at the time of prediction.

        `starting_state=None (|list[int])`: List of initial values for each compartment.
            This is used as the initial vector for the integration process.
            If no `starting_state` is provided, it will default to the having only 1 person in the next non-Susceptible compartment.

        `delta=1 (|float)`: Δ, the step size for the integration process.
            Smaller values will result in more accurate predictions,
            but will be more costly.

        ## Returns

        A list of lists; each sublist is a vector representing the value of each compartment at that specific time.
        The sublists range according to the `timesteps` parameter.
        (`list[list[float]]`)

        ## Example

        For example, the following would be an expected return type for
        an SIR model with a population of `100`:

        ```python
        [
            [99, 1, 0],  # S, I, R on day 1
            [98, 2, 0],  # S, I, R on day 2
            [95, 3, 2],  # S, I, R on day 3
            ...,
            [23, 24, 53]  # final prediction
        ]
        ```

        &#34;&#34;&#34;
        # checks to make sure the model has been compiled
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        # initial parameter setup
        results = []

        if starting_state is not None:
            system = starting_state
        else:
            system = np.zeros(len(self.compartments))
            system[0] = self.initial_population - 1
            system[1] = 1

        delta = timesteps[1] - timesteps[0]

        for timestep in timesteps:

            # calculate the derivative for each compartment at this
            # timestep and update the system accordingly

            derivatives = self.diff(timestep, system)
            system += delta * derivatives
            results.append(deepcopy(system))

        return results

    def add(self, comp, comp_map, matrix):
        &#34;&#34;&#34;
        Add a compartment to the model.
        This can also be done by initializing the `epispot.models.Model` class beforehand.

        ## Parameters

        `comp (epispot.comps.Compartment)`: Compartment class (e.g. `epispot.comps.Susceptible` or `epispot.comps.Infected`)

        `comp_map (list[int])`: Slice of the larger `map` specified in `epispot.models.Model`.
            This should simply include the compartment connections for this specific compartment.

        `matrix (list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)])`: Slice of the larger `matrix` specified in
                  `epispot.models.Model`. As with `map`, this should
                  only include the rates and probabilities for this
                  compartment&#39;s connections.

        ## Error Handling

        Initializing some parameters in `epispot.models.Model` without initializing all of them will raise a `ValueError`.

        ## Additional Notes

        See the documentation for `epispot.models.Model` for more help and examples.

        &#34;&#34;&#34;
        if self.compiled:
            self.compiled = False

        if (self.compartments, self.map, self.matrix) == (None, None, None):
            self.compartments = [comp]
            self.names = [comp.name]
            self.map = [comp_map]
            self.matrix = [matrix]
        elif self.compartments is not None \
            and self.map is not None \
            and self.matrix is not None:
            self.compartments.append(comp)
            self.names.append(comp.name)
            self.map.append(comp_map)
            self.matrix.append(matrix)
        else:  # pragma: no cover
            raise ValueError(&#39;Parameters for `epispot.models.Model` &#39;
                             &#39;have not been specified correctly.\n&#39;
                             &#39;If either `comps`, `map`, or `matrix` &#39;
                             &#39;have been initialized, then *all* &#39;
                             &#39;parameters must be initialized.&#39;)

    def rename(self, names):
        &#34;&#34;&#34;
        Assign names to each compartment in the model.

        ## Parameters

        `names (list[str])`: A list of names corresponding to `comps`

        &#34;&#34;&#34;
        self.names = names
        for i, comp in enumerate(self.compartments):
            comp.name = names[i]

    def save(self, filename):
        &#34;&#34;&#34;
        Save the model to a file.
        This can be used to load the model later.
        Standard file ending is `.epi`.

        ## Parameters

        `filename (str)`: Name of the file to save the model to

        ## Error Handling

        - If the file already exists, it will be overwritten.
        - If the model is not compiled, it will raise a `ValueError`.

        &#34;&#34;&#34;
        if not self.compiled:  # pragma: no cover
            raise ValueError(&#39;Model has not been compiled yet. &#39;
                             &#39;Cannot save model.&#39;)

        with open(filename, &#39;wb&#39;) as f:
            dill.dump(self, f)

    @classmethod
    def load(cls, filename):
        &#34;&#34;&#34;
        Load a model from a file.

        ## Parameters

        `filename (str)`: Name of the file to load the model from

        ## Security

        ..warning::
            Be careful when loading a model from a file. Untrusted sources
            could potentially embed malicious code into various parts of the
            model which can lead to arbitrary code execution.

        ## Error Handling

        - If the file does not exist, it will raise a
          `FileNotFoundError`.

        &#34;&#34;&#34;
        with open(filename, &#39;rb&#39;) as f:
            loaded = dill.load(f)
            if not loaded.compiled:  # pragma: no cover
                loaded.compile()
            if loaded.version != version:  # pragma: no cover
                warnings.warn(
                    &#39;This model has been imported from an &#39;
                    f&#39;older version of epispot v{loaded.version}. &#39;
                    f&#39;You have epispot v{version}.&#39;
                )
            return loaded</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="epispot.models.Model.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a model from a file.</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename (str)</code>: Name of the file to load the model from</p>
<h2 id="security">Security</h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be careful when loading a model from a file. Untrusted sources
could potentially embed malicious code into various parts of the
model which can lead to arbitrary code execution.</p>
</div>
<h2 id="error-handling">Error Handling</h2>
<ul>
<li>If the file does not exist, it will raise a
<code>FileNotFoundError</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, filename):
    &#34;&#34;&#34;
    Load a model from a file.

    ## Parameters

    `filename (str)`: Name of the file to load the model from

    ## Security

    ..warning::
        Be careful when loading a model from a file. Untrusted sources
        could potentially embed malicious code into various parts of the
        model which can lead to arbitrary code execution.

    ## Error Handling

    - If the file does not exist, it will raise a
      `FileNotFoundError`.

    &#34;&#34;&#34;
    with open(filename, &#39;rb&#39;) as f:
        loaded = dill.load(f)
        if not loaded.compiled:  # pragma: no cover
            loaded.compile()
        if loaded.version != version:  # pragma: no cover
            warnings.warn(
                &#39;This model has been imported from an &#39;
                f&#39;older version of epispot v{loaded.version}. &#39;
                f&#39;You have epispot v{version}.&#39;
            )
        return loaded</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="epispot.models.Model.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, comp, comp_map, matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a compartment to the model.
This can also be done by initializing the <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> class beforehand.</p>
<h2 id="parameters">Parameters</h2>
<p><code>comp (<a title="epispot.comps.Compartment" href="comps.html#epispot.comps.Compartment">Compartment</a>)</code>: Compartment class (e.g. <code><a title="epispot.comps.Susceptible" href="comps.html#epispot.comps.Susceptible">Susceptible</a></code> or <code><a title="epispot.comps.Infected" href="comps.html#epispot.comps.Infected">Infected</a></code>)</p>
<p><code>comp_map (list[int])</code>: Slice of the larger <code>map</code> specified in <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code>.
This should simply include the compartment connections for this specific compartment.</p>
<p><code>matrix (list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)])</code>: Slice of the larger <code>matrix</code> specified in
<code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code>. As with <code>map</code>, this should
only include the rates and probabilities for this
compartment's connections.</p>
<h2 id="error-handling">Error Handling</h2>
<p>Initializing some parameters in <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> without initializing all of them will raise a <code>ValueError</code>.</p>
<h2 id="additional-notes">Additional Notes</h2>
<p>See the documentation for <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> for more help and examples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, comp, comp_map, matrix):
    &#34;&#34;&#34;
    Add a compartment to the model.
    This can also be done by initializing the `epispot.models.Model` class beforehand.

    ## Parameters

    `comp (epispot.comps.Compartment)`: Compartment class (e.g. `epispot.comps.Susceptible` or `epispot.comps.Infected`)

    `comp_map (list[int])`: Slice of the larger `map` specified in `epispot.models.Model`.
        This should simply include the compartment connections for this specific compartment.

    `matrix (list[tuple(float|func(t: float)-&gt;float, float|func(t: float)-&gt;float)])`: Slice of the larger `matrix` specified in
              `epispot.models.Model`. As with `map`, this should
              only include the rates and probabilities for this
              compartment&#39;s connections.

    ## Error Handling

    Initializing some parameters in `epispot.models.Model` without initializing all of them will raise a `ValueError`.

    ## Additional Notes

    See the documentation for `epispot.models.Model` for more help and examples.

    &#34;&#34;&#34;
    if self.compiled:
        self.compiled = False

    if (self.compartments, self.map, self.matrix) == (None, None, None):
        self.compartments = [comp]
        self.names = [comp.name]
        self.map = [comp_map]
        self.matrix = [matrix]
    elif self.compartments is not None \
        and self.map is not None \
        and self.matrix is not None:
        self.compartments.append(comp)
        self.names.append(comp.name)
        self.map.append(comp_map)
        self.matrix.append(matrix)
    else:  # pragma: no cover
        raise ValueError(&#39;Parameters for `epispot.models.Model` &#39;
                         &#39;have not been specified correctly.\n&#39;
                         &#39;If either `comps`, `map`, or `matrix` &#39;
                         &#39;have been initialized, then *all* &#39;
                         &#39;parameters must be initialized.&#39;)</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, custom=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a series of checks of the model and initialize some class-wide variables.</p>
<h2 id="parameters">Parameters</h2>
<p><code>custom=False (bool)</code>: Flag indicating if the model is using custom compartments.
If this is <code>False</code> (the default), all compartment compatibility checks will have to pass or an error will be raised.
If this is <code>True</code>, those checks are bypassed since the model cannot check for custom compartments.</p>
<h2 id="additional-notes">Additional Notes</h2>
<p>Adding, removing, or modifying compartments after this step will automatically de-compile the model,
requiring it to be compiled again after changes have been made.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Only run after all the compartments have been
added to the model.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self, custom=False):
    &#34;&#34;&#34;
    Run a series of checks of the model and initialize some class-wide variables.

    ## Parameters

    `custom=False (bool)`: Flag indicating if the model is using custom compartments.
        If this is `False` (the default), all compartment compatibility checks will have to pass or an error will be raised.
        If this is `True`, those checks are bypassed since the model cannot check for custom compartments.

    ## Additional Notes

    Adding, removing, or modifying compartments after this step will automatically de-compile the model,
    requiring it to be compiled again after changes have been made.

    .. important::
       Only run after all the compartments have been
       added to the model.

    &#34;&#34;&#34;
    if self.compiled:  # pragma: no cover
        warnings.warn(&#34;It looks like you&#39;re compiling a model more &#34;
                      &#34;than once. For clarity, it is recommended &#34;
                      &#34;that you only compile models once, and then &#34;
                      &#34;again if (and only if) changes have been &#34;
                      &#34;made.&#34;)

    # run model checks to ensure that the model is valid
    if not custom:
        for i, compartment in enumerate(self.compartments):
            compartment._check(self.map[i], self.compartments)

    # aggregate all compartments by type
    self.aggregated = {}
    for i, compartment in enumerate(self.compartments):
        if compartment.config[&#39;type&#39;] not in self.aggregated:
            self.aggregated[compartment.config[&#39;type&#39;]] = []
        self.aggregated[compartment.config[&#39;type&#39;]].append(i)

    self.compiled = True</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, time, system)</span>
</code></dt>
<dd>
<div class="desc"><p>Differentiate <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code>; used by <code><a title="epispot.models.Model.integrate" href="#epispot.models.Model.integrate">Model.integrate()</a></code> for evaluating model predictions.</p>
<h2 id="parameters">Parameters</h2>
<p><code>time (float)</code>: Time to take the derivative at.
This is important for some time-dependent variables like compartment parameters.</p>
<p><code>system (list[float])</code>: System of state values (e.g <code>[973, 12, 15]</code>).
This is propagated to each of the individual compartments in the model.</p>
<h2 id="returns">Returns</h2>
<p>List of corresponding compartment derivatives (<code>list[float]</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(self, time, system):
    &#34;&#34;&#34;
    Differentiate `epispot.models.Model`; used by `epispot.models.Model.integrate` for evaluating model predictions.

    ## Parameters

    `time (float)`: Time to take the derivative at.
        This is important for some time-dependent variables like compartment parameters.

    `system (list[float])`: System of state values (e.g `[973, 12, 15]`).
        This is propagated to each of the individual compartments in the model.

    ## Returns

    List of corresponding compartment derivatives (`list[float]`)

    &#34;&#34;&#34;
    if not self.compiled:  # pragma: no cover
        warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                      &#39;Triggering integration will automatically &#39;
                      &#39;compile the model.&#39;)
        self.compile()

    derivative = np.zeros((len(self.compartments), ))
    for num, compartment in enumerate(self.compartments):
        if num in self.aggregated[&#39;Susceptible&#39;]:
            delta = compartment.diff(
                time, system, num,
                self.map[num], self.matrix[num],
                infecteds=self.aggregated[&#39;Infected&#39;]
            )
        else:
            delta = compartment.diff(time,
                                     system,
                                     num,
                                     self.map[num],
                                     self.matrix[num])
        derivative += delta

    return derivative</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>self, timesteps, starting_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Integrate the model using <code><a title="epispot.models.Model.diff" href="#epispot.models.Model.diff">Model.diff()</a></code> to arrive at future predictions using
<a href="https://en.wikipedia.org/wiki/Euler_method">Euler's Method</a>.
By default, the step size (Δ) is set to exactly 1 day, as this is usually the period for which epidemiological parameters are estimated for.
However, this can be changed if necessary.</p>
<h2 id="parameters">Parameters</h2>
<p><code>timesteps (range)</code>: range of evenly-spaced times starting at the epidemic start time and ending at the time of prediction.</p>
<p><code>starting_state=None (|list[int])</code>: List of initial values for each compartment.
This is used as the initial vector for the integration process.
If no <code>starting_state</code> is provided, it will default to the having only 1 person in the next non-Susceptible compartment.</p>
<p><code>delta=1 (|float)</code>: Δ, the step size for the integration process.
Smaller values will result in more accurate predictions,
but will be more costly.</p>
<h2 id="returns">Returns</h2>
<p>A list of lists; each sublist is a vector representing the value of each compartment at that specific time.
The sublists range according to the <code>timesteps</code> parameter.
(<code>list[list[float]]</code>)</p>
<h2 id="example">Example</h2>
<p>For example, the following would be an expected return type for
an SIR model with a population of <code>100</code>:</p>
<pre><code class="language-python">[
    [99, 1, 0],  # S, I, R on day 1
    [98, 2, 0],  # S, I, R on day 2
    [95, 3, 2],  # S, I, R on day 3
    ...,
    [23, 24, 53]  # final prediction
]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(self, timesteps, starting_state=None):
    &#34;&#34;&#34;
    Integrate the model using `epispot.models.Model.diff` to arrive at future predictions using
    [Euler&#39;s Method](https://en.wikipedia.org/wiki/Euler_method).
    By default, the step size (Δ) is set to exactly 1 day, as this is usually the period for which epidemiological parameters are estimated for.
    However, this can be changed if necessary.

    ## Parameters

    `timesteps (range)`: range of evenly-spaced times starting at the epidemic start time and ending at the time of prediction.

    `starting_state=None (|list[int])`: List of initial values for each compartment.
        This is used as the initial vector for the integration process.
        If no `starting_state` is provided, it will default to the having only 1 person in the next non-Susceptible compartment.

    `delta=1 (|float)`: Δ, the step size for the integration process.
        Smaller values will result in more accurate predictions,
        but will be more costly.

    ## Returns

    A list of lists; each sublist is a vector representing the value of each compartment at that specific time.
    The sublists range according to the `timesteps` parameter.
    (`list[list[float]]`)

    ## Example

    For example, the following would be an expected return type for
    an SIR model with a population of `100`:

    ```python
    [
        [99, 1, 0],  # S, I, R on day 1
        [98, 2, 0],  # S, I, R on day 2
        [95, 3, 2],  # S, I, R on day 3
        ...,
        [23, 24, 53]  # final prediction
    ]
    ```

    &#34;&#34;&#34;
    # checks to make sure the model has been compiled
    if not self.compiled:  # pragma: no cover
        warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                      &#39;Triggering integration will automatically &#39;
                      &#39;compile the model.&#39;)
        self.compile()

    # initial parameter setup
    results = []

    if starting_state is not None:
        system = starting_state
    else:
        system = np.zeros(len(self.compartments))
        system[0] = self.initial_population - 1
        system[1] = 1

    delta = timesteps[1] - timesteps[0]

    for timestep in timesteps:

        # calculate the derivative for each compartment at this
        # timestep and update the system accordingly

        derivatives = self.diff(timestep, system)
        system += delta * derivatives
        results.append(deepcopy(system))

    return results</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign names to each compartment in the model.</p>
<h2 id="parameters">Parameters</h2>
<p><code>names (list[str])</code>: A list of names corresponding to <code>comps</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self, names):
    &#34;&#34;&#34;
    Assign names to each compartment in the model.

    ## Parameters

    `names (list[str])`: A list of names corresponding to `comps`

    &#34;&#34;&#34;
    self.names = names
    for i, comp in enumerate(self.compartments):
        comp.name = names[i]</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the model to a file.
This can be used to load the model later.
Standard file ending is <code>.epi</code>.</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename (str)</code>: Name of the file to save the model to</p>
<h2 id="error-handling">Error Handling</h2>
<ul>
<li>If the file already exists, it will be overwritten.</li>
<li>If the model is not compiled, it will raise a <code>ValueError</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename):
    &#34;&#34;&#34;
    Save the model to a file.
    This can be used to load the model later.
    Standard file ending is `.epi`.

    ## Parameters

    `filename (str)`: Name of the file to save the model to

    ## Error Handling

    - If the file already exists, it will be overwritten.
    - If the model is not compiled, it will raise a `ValueError`.

    &#34;&#34;&#34;
    if not self.compiled:  # pragma: no cover
        raise ValueError(&#39;Model has not been compiled yet. &#39;
                         &#39;Cannot save model.&#39;)

    with open(filename, &#39;wb&#39;) as f:
        dill.dump(self, f)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="epispot" href="index.html">epispot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code></h4>
<ul class="two-column">
<li><code><a title="epispot.models.Model.add" href="#epispot.models.Model.add">add</a></code></li>
<li><code><a title="epispot.models.Model.compile" href="#epispot.models.Model.compile">compile</a></code></li>
<li><code><a title="epispot.models.Model.diff" href="#epispot.models.Model.diff">diff</a></code></li>
<li><code><a title="epispot.models.Model.integrate" href="#epispot.models.Model.integrate">integrate</a></code></li>
<li><code><a title="epispot.models.Model.load" href="#epispot.models.Model.load">load</a></code></li>
<li><code><a title="epispot.models.Model.rename" href="#epispot.models.Model.rename">rename</a></code></li>
<li><code><a title="epispot.models.Model.save" href="#epispot.models.Model.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>