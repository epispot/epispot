<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>epispot.models API documentation</title>
<meta name="description" content="The `epispot.models` classes store different types of epidemiological
models in a compact form useful for integration. Models can be
differentiated, …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>epispot.models</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="epispot.models" href="#epispot.models">epispot.models</a></code> classes store different types of epidemiological
models in a compact form useful for integration. Models can be
differentiated, integrated, and examined by calling class methods.
Additionally, epispot models are portable—they can be used throughout
the package to generate plots, run predictions, etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The `epispot.models` classes store different types of epidemiological 
models in a compact form useful for integration. Models can be 
differentiated, integrated, and examined by calling class methods. 
Additionally, epispot models are portable—they can be used throughout 
the package to generate plots, run predictions, etc.
&#34;&#34;&#34;

from copy import deepcopy
from . import warnings
from . import np


class Model(object):
    &#34;&#34;&#34;
    The base model class for 
    [compartmental models](https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology). 
    Compartmental models are models composed of various sub-models, 
    known as &#34;compartments.&#34; For example, the common SIR model is an 
    example of a compartmental model with the Susceptible, Infected, 
    and Removed compartments.

    .. versionadded:: v3.0.0-alpha-2

    &#34;&#34;&#34;
    def __init__(self, initial_population, comps=None, comp_map=None, 
                 matrix=None):
        &#34;&#34;&#34;
        Initialize the `Model` class; all optional parameters can be 
        added through the `epispot.models.Model.add` method.

        ## **Parameters**

        `initial_population`: Population at time zero

        `comps=None`: List of compartment classes to create the model

        `comp_map=None`: Map of how all the compartments connect.
                         The map should consist of a list of lists.
                         Each sublist represents the connections of the 
                         corresponding compartment in the `comps` list.
                         This sublist should contain the indices of each 
                         of the compartments in `comps` that it connects to.
                         If the compartment does not connect to any other 
                         compartments, leave the sublist blank.
        
        `matrix=None`: Rate and probability matrix describing the 
                       exchange rates between compartments. Like `map`,
                       this is a list of lists. Unlike `map`, however,
                       this matrix must not skip entries (i.e. no blank
                       sublists). Each sublist should contain rate and 
                       probability information in a tuple for every 
                       compartment. If the information is not 
                       necessary, use the tuple `(1, 1)` or `None` as a
                       placeholder.

        ## **Example**

        Let&#39;s say we have three compartments `A`, `B`, and `C`.
        These three compartments connect as shown below:

        ```text
        ┌───────────────────┐
        │                   ▼
        ┌───┐     ┌───┐     ┌───┐
        │ A │ ──▶ │ C │ ──▶ │ B │
        └───┘     └───┘     └───┘
        ```

        To create a compartmental model with these three classes, use:

        ```python
        comps = [A, B, C], 
        map = [
            [1, 2],     # A
            [],         # B
            [1]         # C
        ],
        matrix = [
            [None, (1/2, 1/3), (1/2, 1/3)],     # A[A, B, C] 
            [None, None, None],                 # B[A, B, C]
            [None, (1/2, 1/3), None]            # C[A, B, C]
        ]
        ```

        This creates a compartmental model where all the connections 
        have a probability of `1/2` and rate of `1/3`.
        
        ## **Additional Notes**

        This feature is currently only released to alpha versions of 
        epispot. This will likely be used (with minor changes) in the 
        full release of epispot v3. For more information about this 
        feature, or if you&#39;re interested in giving feedback, see the 
        discussion 
        [here on GitHub](https://github.com/epispot/epispot/issues/73).

        .. warning::
           As this is currently an alpha feature, the new compartmental 
           models in epispot are subject to change.

        &#34;&#34;&#34;
        self.initial_population = initial_population
        self.compartments = comps
        if self.compartments:
            self.names = [comp.name for comp in self.compartments]
        self.map = comp_map
        self.matrix = matrix
        self.aggregated = None
        self.compiled = False

    def compile(self, custom=False):
        &#34;&#34;&#34;
        Run a series of checks of the model and initialize some 
        class-wide variables.

        ## **Parameters**

        `custom=False`: Flag indicating if the model is using custom
                        compartments. If this is `False` (the default), 
                        all compartment compatibility checks will have 
                        to pass or an error will be raised. If this is 
                        `True`, those checks are bypassed since the 
                        model cannot check for custom compartments.

        ## **Additional Notes**

        Adding, removing, or modifying compartments after this step 
        will automatically de-compile the model, requiring it to be 
        compiled again after changes have been made.

        .. important:: 
           Only run after all the compartments have been
           added to the model.

        &#34;&#34;&#34;
        if self.compiled:  # pragma: no cover
            warnings.warn(&#34;It looks like you&#39;re compiling a model more &#34;
                          &#34;than once. For clarity, it is recommended &#34;
                          &#34;that you only compile models once, and then &#34;
                          &#34;again if (and only if) changes have been &#34;
                          &#34;made.&#34;)

        # run model checks to ensure that the model is valid
        if not custom:
            for i, compartment in enumerate(self.compartments):
                compartment._check(self.map[i], self.compartments)
        
        # aggregate all compartments by type
        self.aggregated = {}
        for i, compartment in enumerate(self.compartments):
            if compartment.config[&#39;type&#39;] not in self.aggregated:
                self.aggregated[compartment.config[&#39;type&#39;]] = []
            self.aggregated[compartment.config[&#39;type&#39;]].append(i)

        self.compiled = True

    def diff(self, time, system):
        &#34;&#34;&#34;
        Differentiate `epispot.models.Model`. Used by 
        `epispot.models.Model.integrate` for evaluating model 
        predictions.

        ## **Parameters**

        `time`: Time to take the derivative at. This is important for 
                some time-dependent variables like compartment 
                parameters.

        `system`: System of state values (e.g `[973, 12, 15]`). This is 
                propagated to each of the individual compartments in 
                the model.

        ## **Return**

        List of corresponding compartment derivatives.
        
        &#34;&#34;&#34;
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        derivative = np.zeros((len(self.compartments), ))
        for num, compartment in enumerate(self.compartments):
            if num in self.aggregated[&#39;Susceptible&#39;]:
                delta = compartment.diff(time, 
                                         system, 
                                         num,
                                         self.map[num], 
                                         self.matrix[num],
                                         infecteds=
                                         self.aggregated[&#39;Infected&#39;])
            else:
                delta = compartment.diff(time, 
                                         system, 
                                         num,
                                         self.map[num], 
                                         self.matrix[num])
            derivative += delta
        
        return derivative

    def integrate(self, timesteps, starting_state=None):
        &#34;&#34;&#34;
        Integrate the model using `epispot.models.Model.diff` to 
        arrive at future predictions using 
        [Euler&#39;s Method](https://en.wikipedia.org/wiki/Euler_method).
        By default, the step size (Δ) is set to exactly 1 day, as this 
        is usually the period for which epidemiological parameters are 
        estimated for. However, in future versions, we plan to update 
        this to add support for variable values of Δ.

        ## **Parameters**

        `timesteps`: range of evenly-spaced times starting at the 
                     epidemic start time and ending at the time of 
                     prediction.
        
        `starting_state=None`: List of initial values for each 
                               compartment. This is used as the initial 
                               vector for the integration process.
                               If no `starting_state` is provided, it 
                               will default to the having only 1 person
                               in the next non-Susceptible compartment.
        
        ## **Return**

        A list of lists. Each sublist is a vector representing the 
        value of each compartment at that specific time. The sublists
        range according to the `timesteps` parameter.

        ## **Example**

        For example, the following would be an expected return type for 
        an SIR model with a population of `100`.

        ```python
        [
            [99, 1, 0],  # S, I, R on day 1
            [98, 2, 0],  # S, I, R on day 2
            [95, 3, 2],  # S, I, R on day 3
            ...,
            [23, 24, 53]  # final prediction
        ]
        ```

        ## **Additional Notes**

        `delta` is expected to be added as an optional parameter in
        future releases of epispot v3. For now, however, it is set 
        to 1 day and cannot be changed.

        &#34;&#34;&#34;
        # checks to make sure the model has been compiled
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        # initial parameter setup
        results = []
        delta = 1

        if starting_state is not None:
            system = starting_state
        else:
            system = np.zeros(len(self.compartments))
            system[0] = self.initial_population - 1
            system[1] = 1

        for timestep in timesteps:

            # calculate the derivative for each compartment at this 
            # timestep and update the system accordingly

            derivatives = self.diff(timestep, system)
            system += delta * derivatives
            results.append(deepcopy(system))

        return results

    def add(self, comp, comp_map, matrix):
        &#34;&#34;&#34;
        Add a compartment to the model. This can also be done by 
        initializing the `epispot.models.Model` class beforehand.

        ## **Parameters**

        `comp`: Compartment class (e.g. `Susceptible()` or `Infected()`)

        `comp_map`: Slice of the larger `map` specified in 
                    `epispot.models.Model`. This should simply include the 
                    compartment connections for this specific compartment.

        `matrix`: Slice of the larger `matrix` specified in 
                  `epispot.models.Model`. As with `map`, this should 
                  only include the rates and probabilities for this
                  compartment&#39;s connections.

        ## **Error Handling**

        Initializing some parameters in `epispot.models.Model` without
        initializing all of them will raise a `ValueError`.

        ## **Additional Notes**

        See the documentation for `epispot.models.Model` for more help
        and examples.

        &#34;&#34;&#34;
        if self.compiled:
            self.compiled = False

        if (self.compartments, self.map, self.matrix) == (None, None, None):
            self.compartments = [comp]
            self.names = [comp.name]
            self.map = [comp_map]
            self.matrix = [matrix]
        elif self.compartments is not None and self.map is not None and \
             self.matrix is not None:
            self.compartments.append(comp)
            self.names.append(comp.name)
            self.map.append(comp_map)
            self.matrix.append(matrix)
        else:  # pragma: no cover
            raise ValueError(&#39;Parameters for `epispot.models.Model` &#39;
                             &#39;have not been specified correctly.\n&#39;
                             &#39;If either `comps`, `map`, or `matrix` &#39;
                             &#39;have been initialized, then *all* &#39;
                             &#39;parameters must be initialized.&#39;)

    def rename(self, names):
        &#34;&#34;&#34;
        Assign names to each compartment in the model.

        ## Parameters

        `names`: A list of names corresponding to `comps`

        &#34;&#34;&#34;
        self.names = names
        for i, comp in enumerate(self.compartments):
            comp.name = names[i]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="epispot.models.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>initial_population, comps=None, comp_map=None, matrix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base model class for
<a href="https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology">compartmental models</a>.
Compartmental models are models composed of various sub-models,
known as "compartments." For example, the common SIR model is an
example of a compartmental model with the Susceptible, Infected,
and Removed compartments.</p>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;v3.0.0-alpha-2</p>
</div>
<p>Initialize the <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> class; all optional parameters can be
added through the <code><a title="epispot.models.Model.add" href="#epispot.models.Model.add">Model.add()</a></code> method.</p>
<h2 id="parameters"><strong>Parameters</strong></h2>
<p><code>initial_population</code>: Population at time zero</p>
<p><code>comps=None</code>: List of compartment classes to create the model</p>
<p><code>comp_map=None</code>: Map of how all the compartments connect.
The map should consist of a list of lists.
Each sublist represents the connections of the
corresponding compartment in the <code>comps</code> list.
This sublist should contain the indices of each
of the compartments in <code>comps</code> that it connects to.
If the compartment does not connect to any other
compartments, leave the sublist blank.</p>
<p><code>matrix=None</code>: Rate and probability matrix describing the
exchange rates between compartments. Like <code>map</code>,
this is a list of lists. Unlike <code>map</code>, however,
this matrix must not skip entries (i.e. no blank
sublists). Each sublist should contain rate and
probability information in a tuple for every
compartment. If the information is not
necessary, use the tuple <code>(1, 1)</code> or <code>None</code> as a
placeholder.</p>
<h2 id="example"><strong>Example</strong></h2>
<p>Let's say we have three compartments <code>A</code>, <code>B</code>, and <code>C</code>.
These three compartments connect as shown below:</p>
<pre><code class="language-text">┌───────────────────┐
│                   ▼
┌───┐     ┌───┐     ┌───┐
│ A │ ──▶ │ C │ ──▶ │ B │
└───┘     └───┘     └───┘
</code></pre>
<p>To create a compartmental model with these three classes, use:</p>
<pre><code class="language-python">comps = [A, B, C], 
map = [
    [1, 2],     # A
    [],         # B
    [1]         # C
],
matrix = [
    [None, (1/2, 1/3), (1/2, 1/3)],     # A[A, B, C] 
    [None, None, None],                 # B[A, B, C]
    [None, (1/2, 1/3), None]            # C[A, B, C]
]
</code></pre>
<p>This creates a compartmental model where all the connections
have a probability of <code>1/2</code> and rate of <code>1/3</code>.</p>
<h2 id="additional-notes"><strong>Additional Notes</strong></h2>
<p>This feature is currently only released to alpha versions of
epispot. This will likely be used (with minor changes) in the
full release of epispot v3. For more information about this
feature, or if you're interested in giving feedback, see the
discussion
<a href="https://github.com/epispot/epispot/issues/73">here on GitHub</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As this is currently an alpha feature, the new compartmental
models in epispot are subject to change.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model(object):
    &#34;&#34;&#34;
    The base model class for 
    [compartmental models](https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology). 
    Compartmental models are models composed of various sub-models, 
    known as &#34;compartments.&#34; For example, the common SIR model is an 
    example of a compartmental model with the Susceptible, Infected, 
    and Removed compartments.

    .. versionadded:: v3.0.0-alpha-2

    &#34;&#34;&#34;
    def __init__(self, initial_population, comps=None, comp_map=None, 
                 matrix=None):
        &#34;&#34;&#34;
        Initialize the `Model` class; all optional parameters can be 
        added through the `epispot.models.Model.add` method.

        ## **Parameters**

        `initial_population`: Population at time zero

        `comps=None`: List of compartment classes to create the model

        `comp_map=None`: Map of how all the compartments connect.
                         The map should consist of a list of lists.
                         Each sublist represents the connections of the 
                         corresponding compartment in the `comps` list.
                         This sublist should contain the indices of each 
                         of the compartments in `comps` that it connects to.
                         If the compartment does not connect to any other 
                         compartments, leave the sublist blank.
        
        `matrix=None`: Rate and probability matrix describing the 
                       exchange rates between compartments. Like `map`,
                       this is a list of lists. Unlike `map`, however,
                       this matrix must not skip entries (i.e. no blank
                       sublists). Each sublist should contain rate and 
                       probability information in a tuple for every 
                       compartment. If the information is not 
                       necessary, use the tuple `(1, 1)` or `None` as a
                       placeholder.

        ## **Example**

        Let&#39;s say we have three compartments `A`, `B`, and `C`.
        These three compartments connect as shown below:

        ```text
        ┌───────────────────┐
        │                   ▼
        ┌───┐     ┌───┐     ┌───┐
        │ A │ ──▶ │ C │ ──▶ │ B │
        └───┘     └───┘     └───┘
        ```

        To create a compartmental model with these three classes, use:

        ```python
        comps = [A, B, C], 
        map = [
            [1, 2],     # A
            [],         # B
            [1]         # C
        ],
        matrix = [
            [None, (1/2, 1/3), (1/2, 1/3)],     # A[A, B, C] 
            [None, None, None],                 # B[A, B, C]
            [None, (1/2, 1/3), None]            # C[A, B, C]
        ]
        ```

        This creates a compartmental model where all the connections 
        have a probability of `1/2` and rate of `1/3`.
        
        ## **Additional Notes**

        This feature is currently only released to alpha versions of 
        epispot. This will likely be used (with minor changes) in the 
        full release of epispot v3. For more information about this 
        feature, or if you&#39;re interested in giving feedback, see the 
        discussion 
        [here on GitHub](https://github.com/epispot/epispot/issues/73).

        .. warning::
           As this is currently an alpha feature, the new compartmental 
           models in epispot are subject to change.

        &#34;&#34;&#34;
        self.initial_population = initial_population
        self.compartments = comps
        if self.compartments:
            self.names = [comp.name for comp in self.compartments]
        self.map = comp_map
        self.matrix = matrix
        self.aggregated = None
        self.compiled = False

    def compile(self, custom=False):
        &#34;&#34;&#34;
        Run a series of checks of the model and initialize some 
        class-wide variables.

        ## **Parameters**

        `custom=False`: Flag indicating if the model is using custom
                        compartments. If this is `False` (the default), 
                        all compartment compatibility checks will have 
                        to pass or an error will be raised. If this is 
                        `True`, those checks are bypassed since the 
                        model cannot check for custom compartments.

        ## **Additional Notes**

        Adding, removing, or modifying compartments after this step 
        will automatically de-compile the model, requiring it to be 
        compiled again after changes have been made.

        .. important:: 
           Only run after all the compartments have been
           added to the model.

        &#34;&#34;&#34;
        if self.compiled:  # pragma: no cover
            warnings.warn(&#34;It looks like you&#39;re compiling a model more &#34;
                          &#34;than once. For clarity, it is recommended &#34;
                          &#34;that you only compile models once, and then &#34;
                          &#34;again if (and only if) changes have been &#34;
                          &#34;made.&#34;)

        # run model checks to ensure that the model is valid
        if not custom:
            for i, compartment in enumerate(self.compartments):
                compartment._check(self.map[i], self.compartments)
        
        # aggregate all compartments by type
        self.aggregated = {}
        for i, compartment in enumerate(self.compartments):
            if compartment.config[&#39;type&#39;] not in self.aggregated:
                self.aggregated[compartment.config[&#39;type&#39;]] = []
            self.aggregated[compartment.config[&#39;type&#39;]].append(i)

        self.compiled = True

    def diff(self, time, system):
        &#34;&#34;&#34;
        Differentiate `epispot.models.Model`. Used by 
        `epispot.models.Model.integrate` for evaluating model 
        predictions.

        ## **Parameters**

        `time`: Time to take the derivative at. This is important for 
                some time-dependent variables like compartment 
                parameters.

        `system`: System of state values (e.g `[973, 12, 15]`). This is 
                propagated to each of the individual compartments in 
                the model.

        ## **Return**

        List of corresponding compartment derivatives.
        
        &#34;&#34;&#34;
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        derivative = np.zeros((len(self.compartments), ))
        for num, compartment in enumerate(self.compartments):
            if num in self.aggregated[&#39;Susceptible&#39;]:
                delta = compartment.diff(time, 
                                         system, 
                                         num,
                                         self.map[num], 
                                         self.matrix[num],
                                         infecteds=
                                         self.aggregated[&#39;Infected&#39;])
            else:
                delta = compartment.diff(time, 
                                         system, 
                                         num,
                                         self.map[num], 
                                         self.matrix[num])
            derivative += delta
        
        return derivative

    def integrate(self, timesteps, starting_state=None):
        &#34;&#34;&#34;
        Integrate the model using `epispot.models.Model.diff` to 
        arrive at future predictions using 
        [Euler&#39;s Method](https://en.wikipedia.org/wiki/Euler_method).
        By default, the step size (Δ) is set to exactly 1 day, as this 
        is usually the period for which epidemiological parameters are 
        estimated for. However, in future versions, we plan to update 
        this to add support for variable values of Δ.

        ## **Parameters**

        `timesteps`: range of evenly-spaced times starting at the 
                     epidemic start time and ending at the time of 
                     prediction.
        
        `starting_state=None`: List of initial values for each 
                               compartment. This is used as the initial 
                               vector for the integration process.
                               If no `starting_state` is provided, it 
                               will default to the having only 1 person
                               in the next non-Susceptible compartment.
        
        ## **Return**

        A list of lists. Each sublist is a vector representing the 
        value of each compartment at that specific time. The sublists
        range according to the `timesteps` parameter.

        ## **Example**

        For example, the following would be an expected return type for 
        an SIR model with a population of `100`.

        ```python
        [
            [99, 1, 0],  # S, I, R on day 1
            [98, 2, 0],  # S, I, R on day 2
            [95, 3, 2],  # S, I, R on day 3
            ...,
            [23, 24, 53]  # final prediction
        ]
        ```

        ## **Additional Notes**

        `delta` is expected to be added as an optional parameter in
        future releases of epispot v3. For now, however, it is set 
        to 1 day and cannot be changed.

        &#34;&#34;&#34;
        # checks to make sure the model has been compiled
        if not self.compiled:  # pragma: no cover
            warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                          &#39;Triggering integration will automatically &#39;
                          &#39;compile the model.&#39;)
            self.compile()

        # initial parameter setup
        results = []
        delta = 1

        if starting_state is not None:
            system = starting_state
        else:
            system = np.zeros(len(self.compartments))
            system[0] = self.initial_population - 1
            system[1] = 1

        for timestep in timesteps:

            # calculate the derivative for each compartment at this 
            # timestep and update the system accordingly

            derivatives = self.diff(timestep, system)
            system += delta * derivatives
            results.append(deepcopy(system))

        return results

    def add(self, comp, comp_map, matrix):
        &#34;&#34;&#34;
        Add a compartment to the model. This can also be done by 
        initializing the `epispot.models.Model` class beforehand.

        ## **Parameters**

        `comp`: Compartment class (e.g. `Susceptible()` or `Infected()`)

        `comp_map`: Slice of the larger `map` specified in 
                    `epispot.models.Model`. This should simply include the 
                    compartment connections for this specific compartment.

        `matrix`: Slice of the larger `matrix` specified in 
                  `epispot.models.Model`. As with `map`, this should 
                  only include the rates and probabilities for this
                  compartment&#39;s connections.

        ## **Error Handling**

        Initializing some parameters in `epispot.models.Model` without
        initializing all of them will raise a `ValueError`.

        ## **Additional Notes**

        See the documentation for `epispot.models.Model` for more help
        and examples.

        &#34;&#34;&#34;
        if self.compiled:
            self.compiled = False

        if (self.compartments, self.map, self.matrix) == (None, None, None):
            self.compartments = [comp]
            self.names = [comp.name]
            self.map = [comp_map]
            self.matrix = [matrix]
        elif self.compartments is not None and self.map is not None and \
             self.matrix is not None:
            self.compartments.append(comp)
            self.names.append(comp.name)
            self.map.append(comp_map)
            self.matrix.append(matrix)
        else:  # pragma: no cover
            raise ValueError(&#39;Parameters for `epispot.models.Model` &#39;
                             &#39;have not been specified correctly.\n&#39;
                             &#39;If either `comps`, `map`, or `matrix` &#39;
                             &#39;have been initialized, then *all* &#39;
                             &#39;parameters must be initialized.&#39;)

    def rename(self, names):
        &#34;&#34;&#34;
        Assign names to each compartment in the model.

        ## Parameters

        `names`: A list of names corresponding to `comps`

        &#34;&#34;&#34;
        self.names = names
        for i, comp in enumerate(self.compartments):
            comp.name = names[i]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="epispot.models.Model.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, comp, comp_map, matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a compartment to the model. This can also be done by
initializing the <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> class beforehand.</p>
<h2 id="parameters"><strong>Parameters</strong></h2>
<p><code>comp</code>: Compartment class (e.g. <code>Susceptible()</code> or <code>Infected()</code>)</p>
<p><code>comp_map</code>: Slice of the larger <code>map</code> specified in
<code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code>. This should simply include the
compartment connections for this specific compartment.</p>
<p><code>matrix</code>: Slice of the larger <code>matrix</code> specified in
<code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code>. As with <code>map</code>, this should
only include the rates and probabilities for this
compartment's connections.</p>
<h2 id="error-handling"><strong>Error Handling</strong></h2>
<p>Initializing some parameters in <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> without
initializing all of them will raise a <code>ValueError</code>.</p>
<h2 id="additional-notes"><strong>Additional Notes</strong></h2>
<p>See the documentation for <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code> for more help
and examples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, comp, comp_map, matrix):
    &#34;&#34;&#34;
    Add a compartment to the model. This can also be done by 
    initializing the `epispot.models.Model` class beforehand.

    ## **Parameters**

    `comp`: Compartment class (e.g. `Susceptible()` or `Infected()`)

    `comp_map`: Slice of the larger `map` specified in 
                `epispot.models.Model`. This should simply include the 
                compartment connections for this specific compartment.

    `matrix`: Slice of the larger `matrix` specified in 
              `epispot.models.Model`. As with `map`, this should 
              only include the rates and probabilities for this
              compartment&#39;s connections.

    ## **Error Handling**

    Initializing some parameters in `epispot.models.Model` without
    initializing all of them will raise a `ValueError`.

    ## **Additional Notes**

    See the documentation for `epispot.models.Model` for more help
    and examples.

    &#34;&#34;&#34;
    if self.compiled:
        self.compiled = False

    if (self.compartments, self.map, self.matrix) == (None, None, None):
        self.compartments = [comp]
        self.names = [comp.name]
        self.map = [comp_map]
        self.matrix = [matrix]
    elif self.compartments is not None and self.map is not None and \
         self.matrix is not None:
        self.compartments.append(comp)
        self.names.append(comp.name)
        self.map.append(comp_map)
        self.matrix.append(matrix)
    else:  # pragma: no cover
        raise ValueError(&#39;Parameters for `epispot.models.Model` &#39;
                         &#39;have not been specified correctly.\n&#39;
                         &#39;If either `comps`, `map`, or `matrix` &#39;
                         &#39;have been initialized, then *all* &#39;
                         &#39;parameters must be initialized.&#39;)</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, custom=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a series of checks of the model and initialize some
class-wide variables.</p>
<h2 id="parameters"><strong>Parameters</strong></h2>
<p><code>custom=False</code>: Flag indicating if the model is using custom
compartments. If this is <code>False</code> (the default),
all compartment compatibility checks will have
to pass or an error will be raised. If this is
<code>True</code>, those checks are bypassed since the
model cannot check for custom compartments.</p>
<h2 id="additional-notes"><strong>Additional Notes</strong></h2>
<p>Adding, removing, or modifying compartments after this step
will automatically de-compile the model, requiring it to be
compiled again after changes have been made.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Only run after all the compartments have been
added to the model.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self, custom=False):
    &#34;&#34;&#34;
    Run a series of checks of the model and initialize some 
    class-wide variables.

    ## **Parameters**

    `custom=False`: Flag indicating if the model is using custom
                    compartments. If this is `False` (the default), 
                    all compartment compatibility checks will have 
                    to pass or an error will be raised. If this is 
                    `True`, those checks are bypassed since the 
                    model cannot check for custom compartments.

    ## **Additional Notes**

    Adding, removing, or modifying compartments after this step 
    will automatically de-compile the model, requiring it to be 
    compiled again after changes have been made.

    .. important:: 
       Only run after all the compartments have been
       added to the model.

    &#34;&#34;&#34;
    if self.compiled:  # pragma: no cover
        warnings.warn(&#34;It looks like you&#39;re compiling a model more &#34;
                      &#34;than once. For clarity, it is recommended &#34;
                      &#34;that you only compile models once, and then &#34;
                      &#34;again if (and only if) changes have been &#34;
                      &#34;made.&#34;)

    # run model checks to ensure that the model is valid
    if not custom:
        for i, compartment in enumerate(self.compartments):
            compartment._check(self.map[i], self.compartments)
    
    # aggregate all compartments by type
    self.aggregated = {}
    for i, compartment in enumerate(self.compartments):
        if compartment.config[&#39;type&#39;] not in self.aggregated:
            self.aggregated[compartment.config[&#39;type&#39;]] = []
        self.aggregated[compartment.config[&#39;type&#39;]].append(i)

    self.compiled = True</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, time, system)</span>
</code></dt>
<dd>
<div class="desc"><p>Differentiate <code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code>. Used by
<code><a title="epispot.models.Model.integrate" href="#epispot.models.Model.integrate">Model.integrate()</a></code> for evaluating model
predictions.</p>
<h2 id="parameters"><strong>Parameters</strong></h2>
<p><code>time</code>: Time to take the derivative at. This is important for
some time-dependent variables like compartment
parameters.</p>
<p><code>system</code>: System of state values (e.g <code>[973, 12, 15]</code>). This is
propagated to each of the individual compartments in
the model.</p>
<h2 id="return"><strong>Return</strong></h2>
<p>List of corresponding compartment derivatives.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(self, time, system):
    &#34;&#34;&#34;
    Differentiate `epispot.models.Model`. Used by 
    `epispot.models.Model.integrate` for evaluating model 
    predictions.

    ## **Parameters**

    `time`: Time to take the derivative at. This is important for 
            some time-dependent variables like compartment 
            parameters.

    `system`: System of state values (e.g `[973, 12, 15]`). This is 
            propagated to each of the individual compartments in 
            the model.

    ## **Return**

    List of corresponding compartment derivatives.
    
    &#34;&#34;&#34;
    if not self.compiled:  # pragma: no cover
        warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                      &#39;Triggering integration will automatically &#39;
                      &#39;compile the model.&#39;)
        self.compile()

    derivative = np.zeros((len(self.compartments), ))
    for num, compartment in enumerate(self.compartments):
        if num in self.aggregated[&#39;Susceptible&#39;]:
            delta = compartment.diff(time, 
                                     system, 
                                     num,
                                     self.map[num], 
                                     self.matrix[num],
                                     infecteds=
                                     self.aggregated[&#39;Infected&#39;])
        else:
            delta = compartment.diff(time, 
                                     system, 
                                     num,
                                     self.map[num], 
                                     self.matrix[num])
        derivative += delta
    
    return derivative</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>self, timesteps, starting_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Integrate the model using <code><a title="epispot.models.Model.diff" href="#epispot.models.Model.diff">Model.diff()</a></code> to
arrive at future predictions using
<a href="https://en.wikipedia.org/wiki/Euler_method">Euler's Method</a>.
By default, the step size (Δ) is set to exactly 1 day, as this
is usually the period for which epidemiological parameters are
estimated for. However, in future versions, we plan to update
this to add support for variable values of Δ.</p>
<h2 id="parameters"><strong>Parameters</strong></h2>
<p><code>timesteps</code>: range of evenly-spaced times starting at the
epidemic start time and ending at the time of
prediction.</p>
<p><code>starting_state=None</code>: List of initial values for each
compartment. This is used as the initial
vector for the integration process.
If no <code>starting_state</code> is provided, it
will default to the having only 1 person
in the next non-Susceptible compartment.</p>
<h2 id="return"><strong>Return</strong></h2>
<p>A list of lists. Each sublist is a vector representing the
value of each compartment at that specific time. The sublists
range according to the <code>timesteps</code> parameter.</p>
<h2 id="example"><strong>Example</strong></h2>
<p>For example, the following would be an expected return type for
an SIR model with a population of <code>100</code>.</p>
<pre><code class="language-python">[
    [99, 1, 0],  # S, I, R on day 1
    [98, 2, 0],  # S, I, R on day 2
    [95, 3, 2],  # S, I, R on day 3
    ...,
    [23, 24, 53]  # final prediction
]
</code></pre>
<h2 id="additional-notes"><strong>Additional Notes</strong></h2>
<p><code>delta</code> is expected to be added as an optional parameter in
future releases of epispot v3. For now, however, it is set
to 1 day and cannot be changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(self, timesteps, starting_state=None):
    &#34;&#34;&#34;
    Integrate the model using `epispot.models.Model.diff` to 
    arrive at future predictions using 
    [Euler&#39;s Method](https://en.wikipedia.org/wiki/Euler_method).
    By default, the step size (Δ) is set to exactly 1 day, as this 
    is usually the period for which epidemiological parameters are 
    estimated for. However, in future versions, we plan to update 
    this to add support for variable values of Δ.

    ## **Parameters**

    `timesteps`: range of evenly-spaced times starting at the 
                 epidemic start time and ending at the time of 
                 prediction.
    
    `starting_state=None`: List of initial values for each 
                           compartment. This is used as the initial 
                           vector for the integration process.
                           If no `starting_state` is provided, it 
                           will default to the having only 1 person
                           in the next non-Susceptible compartment.
    
    ## **Return**

    A list of lists. Each sublist is a vector representing the 
    value of each compartment at that specific time. The sublists
    range according to the `timesteps` parameter.

    ## **Example**

    For example, the following would be an expected return type for 
    an SIR model with a population of `100`.

    ```python
    [
        [99, 1, 0],  # S, I, R on day 1
        [98, 2, 0],  # S, I, R on day 2
        [95, 3, 2],  # S, I, R on day 3
        ...,
        [23, 24, 53]  # final prediction
    ]
    ```

    ## **Additional Notes**

    `delta` is expected to be added as an optional parameter in
    future releases of epispot v3. For now, however, it is set 
    to 1 day and cannot be changed.

    &#34;&#34;&#34;
    # checks to make sure the model has been compiled
    if not self.compiled:  # pragma: no cover
        warnings.warn(&#39;An epispot model has not been compiled yet. &#39;
                      &#39;Triggering integration will automatically &#39;
                      &#39;compile the model.&#39;)
        self.compile()

    # initial parameter setup
    results = []
    delta = 1

    if starting_state is not None:
        system = starting_state
    else:
        system = np.zeros(len(self.compartments))
        system[0] = self.initial_population - 1
        system[1] = 1

    for timestep in timesteps:

        # calculate the derivative for each compartment at this 
        # timestep and update the system accordingly

        derivatives = self.diff(timestep, system)
        system += delta * derivatives
        results.append(deepcopy(system))

    return results</code></pre>
</details>
</dd>
<dt id="epispot.models.Model.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign names to each compartment in the model.</p>
<h2 id="parameters">Parameters</h2>
<p><code>names</code>: A list of names corresponding to <code>comps</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self, names):
    &#34;&#34;&#34;
    Assign names to each compartment in the model.

    ## Parameters

    `names`: A list of names corresponding to `comps`

    &#34;&#34;&#34;
    self.names = names
    for i, comp in enumerate(self.compartments):
        comp.name = names[i]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="epispot" href="index.html">epispot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="epispot.models.Model" href="#epispot.models.Model">Model</a></code></h4>
<ul class="">
<li><code><a title="epispot.models.Model.add" href="#epispot.models.Model.add">add</a></code></li>
<li><code><a title="epispot.models.Model.compile" href="#epispot.models.Model.compile">compile</a></code></li>
<li><code><a title="epispot.models.Model.diff" href="#epispot.models.Model.diff">diff</a></code></li>
<li><code><a title="epispot.models.Model.integrate" href="#epispot.models.Model.integrate">integrate</a></code></li>
<li><code><a title="epispot.models.Model.rename" href="#epispot.models.Model.rename">rename</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>